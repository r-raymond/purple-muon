-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A multiplayer space game
--   
--   Please see README.md
@package purple-muon
@version 0.0.0

module Server.CommandLine
data CommandLineOptions
CommandLineOptions :: Word32 -> CommandLineOptions
[uuid] :: CommandLineOptions -> Word32
parser :: Parser CommandLineOptions

module PurpleMuon.Video.Types


-- | This module defines common lifting operations into MonadError.
module PurpleMuon.Util.MonadError

-- | Lift a Maybe into an error monad
liftMaybe :: (MonadError e m) => e -> Maybe a -> m a

-- | Lift Either into error monad This version additionally allows to
--   specify a transformation for the <a>Left</a> value.
liftEitherWith :: (MonadError e m) => (f -> e) -> Either f a -> m a

-- | Lift Either into error monad Throws error on <a>Left</a> Value.
liftEither :: (MonadError e m) => Either e a -> m a

-- | Map the error type (<a>Left</a>) of an <a>Either</a>
mapLeft :: (a -> b) -> Either a c -> Either b c

-- | Lift a list into error monad Throws error if list is empty, gives head
--   otherwise
liftList :: (MonadError e m) => e -> [a] -> m a


-- | This module defined types that are used in multiple subcomponents.
--   Instead of having different versions in each subcompoenent, they are
--   collected here. As such, this module is kind of a collection of things
--   without a common denominator.
module PurpleMuon.Types

-- | The floating point type used in PurpleMuon
type FlType = Float

-- | A position type describing a position on the screen. Screen positions
--   are always int the range `[0,1] x [0,1]` and will be rescaled when
--   drawn according to the screen resolution. The physics engine uses the
--   same positions to describe the physical objects.
newtype Position
Position :: V2 FlType -> Position
[unPosition] :: Position -> V2 FlType

-- | A key into a collection of objects
newtype Key a
Key :: Int -> Key a
[unKey] :: Key a -> Int

-- | A color type Red Green Blue Alpha
newtype Color
Color :: V4 Word8 -> Color
[unColor] :: Color -> V4 Word8
newtype Size
Size :: V2 FlType -> Size
[unSize] :: Size -> V2 FlType
instance GHC.Generics.Generic (PurpleMuon.Types.Key a)
instance GHC.Classes.Eq (PurpleMuon.Types.Key a)
instance GHC.Show.Show PurpleMuon.Types.Size
instance GHC.Classes.Eq PurpleMuon.Types.Size
instance GHC.Generics.Generic PurpleMuon.Types.Size
instance GHC.Show.Show PurpleMuon.Types.Position
instance GHC.Classes.Eq PurpleMuon.Types.Position
instance GHC.Generics.Generic PurpleMuon.Types.Position
instance Data.Binary.Class.Binary PurpleMuon.Types.Position
instance Data.Binary.Class.Binary (PurpleMuon.Types.Key a)


-- | This module defines helper function for frame management. It allows to
--   define a wanted frame length and wait if the frame was shorter. It
--   also abstracts over storing frame lengths and calculating FPS.
module PurpleMuon.Util.Frames

-- | Get the current time
getTime :: MonadIO m => m UTCTime

-- | Handle frame time. The function will then calculate the remaining
--   time, sleep the thread, and return the final time of the frame.
manageFps :: MonadIO m => NominalDiffTime -> UTCTime -> m FlType


module PurpleMuon.Physics.Types

-- | A physical object identifier
type PhyObjKey = Key PhysicalObject

-- | The mass of an object
newtype Mass
Mass :: FlType -> Mass
[unMass] :: Mass -> FlType

-- | The velocity of an object
newtype Velocity
Velocity :: V2 FlType -> Velocity
[unVelocity] :: Velocity -> V2 FlType

-- | The acceleration of an object
newtype Acceleration
Acceleration :: V2 FlType -> Acceleration
[unAcceleration] :: Acceleration -> V2 FlType

-- | A time delta Meassured in seconds
newtype DeltaTime
DeltaTime :: FlType -> DeltaTime
[unDeltaTime] :: DeltaTime -> FlType

-- | A Force
newtype Force
Force :: V2 FlType -> Force
[unForce] :: Force -> V2 FlType

-- | The gravitaional constant
newtype GravitationalConstant
GravitationalConstant :: FlType -> GravitationalConstant
[unGravitationalConstant] :: GravitationalConstant -> FlType

-- | A physical object
data PhysicalObject
PhysicalObject :: Mass -> Position -> Velocity -> ObjType -> ObjGrav -> PhysicalObject

-- | The mass of the object
[_mass] :: PhysicalObject -> Mass

-- | The position of the object
[_pos] :: PhysicalObject -> Position

-- | The velocity of the object
[_vel] :: PhysicalObject -> Velocity

-- | Is this object moving?
[_static] :: PhysicalObject -> ObjType

-- | Is this object gravitating?
[_gravitating] :: PhysicalObject -> ObjGrav
mass :: Lens' PhysicalObject Mass
pos :: Lens' PhysicalObject Position
vel :: Lens' PhysicalObject Velocity
static :: Lens' PhysicalObject ObjType
gravitating :: Lens' PhysicalObject ObjGrav

-- | The physical size of the playing board
newtype PhysicalSize
PhysicalSize :: V2 FlType -> PhysicalSize
[unPhysicalSize] :: PhysicalSize -> V2 FlType

-- | The derivaties of a physical object numerical integrater
newtype Derivative
Derivative :: (Velocity, Force) -> Derivative
[unDerviative] :: Derivative -> (Velocity, Force)

-- | A collection of derivaties, indexed by the <tt>uuid</tt> of the
--   objects
type Derivatives = IntMap Derivative

-- | A collection of objects, indexed by the <tt>uuid</tt> of the objects
type PhysicalObjects = IntMap PhysicalObject

-- | A collection of forces, indexed by the <tt>uuid</tt> of the objects
type Forces = IntMap Force

-- | The type of a gravitating body
data ObjGrav

-- | the object exerts gravitational forces
Gravitating :: ObjGrav

-- | the object only recerives grav. forces
NonGravitating :: ObjGrav

-- | The type of a physical object
data ObjType

-- | the objects position is fixed
Static :: ObjType

-- | the objects position is not fixed
NonStatic :: ObjType
instance GHC.Generics.Generic PurpleMuon.Physics.Types.Derivative
instance GHC.Show.Show PurpleMuon.Physics.Types.Derivative
instance GHC.Classes.Eq PurpleMuon.Physics.Types.Derivative
instance GHC.Generics.Generic PurpleMuon.Physics.Types.PhysicalSize
instance GHC.Show.Show PurpleMuon.Physics.Types.PhysicalSize
instance GHC.Classes.Eq PurpleMuon.Physics.Types.PhysicalSize
instance Data.AdditiveGroup.AdditiveGroup PurpleMuon.Physics.Types.Force
instance Data.VectorSpace.VectorSpace PurpleMuon.Physics.Types.Force
instance Data.AdditiveGroup.AdditiveGroup PurpleMuon.Physics.Types.Velocity
instance Data.VectorSpace.VectorSpace PurpleMuon.Physics.Types.Velocity
instance Data.AdditiveGroup.AdditiveGroup PurpleMuon.Physics.Types.Acceleration
instance Data.VectorSpace.VectorSpace PurpleMuon.Physics.Types.Acceleration
instance Data.AdditiveGroup.AdditiveGroup PurpleMuon.Physics.Types.Derivative
instance Data.VectorSpace.VectorSpace PurpleMuon.Physics.Types.Derivative
instance Data.AdditiveGroup.AdditiveGroup PurpleMuon.Physics.Types.DeltaTime
instance GHC.Generics.Generic PurpleMuon.Physics.Types.PhysicalObject
instance GHC.Show.Show PurpleMuon.Physics.Types.PhysicalObject
instance GHC.Generics.Generic PurpleMuon.Physics.Types.ObjGrav
instance GHC.Show.Show PurpleMuon.Physics.Types.ObjGrav
instance GHC.Classes.Eq PurpleMuon.Physics.Types.ObjGrav
instance GHC.Generics.Generic PurpleMuon.Physics.Types.ObjType
instance GHC.Show.Show PurpleMuon.Physics.Types.ObjType
instance GHC.Classes.Eq PurpleMuon.Physics.Types.ObjType
instance GHC.Generics.Generic PurpleMuon.Physics.Types.GravitationalConstant
instance GHC.Show.Show PurpleMuon.Physics.Types.GravitationalConstant
instance GHC.Classes.Eq PurpleMuon.Physics.Types.GravitationalConstant
instance GHC.Generics.Generic PurpleMuon.Physics.Types.Force
instance GHC.Show.Show PurpleMuon.Physics.Types.Force
instance GHC.Classes.Eq PurpleMuon.Physics.Types.Force
instance GHC.Generics.Generic PurpleMuon.Physics.Types.DeltaTime
instance GHC.Classes.Ord PurpleMuon.Physics.Types.DeltaTime
instance GHC.Show.Show PurpleMuon.Physics.Types.DeltaTime
instance GHC.Classes.Eq PurpleMuon.Physics.Types.DeltaTime
instance GHC.Generics.Generic PurpleMuon.Physics.Types.Acceleration
instance GHC.Show.Show PurpleMuon.Physics.Types.Acceleration
instance GHC.Classes.Eq PurpleMuon.Physics.Types.Acceleration
instance GHC.Generics.Generic PurpleMuon.Physics.Types.Velocity
instance GHC.Show.Show PurpleMuon.Physics.Types.Velocity
instance GHC.Classes.Eq PurpleMuon.Physics.Types.Velocity
instance GHC.Generics.Generic PurpleMuon.Physics.Types.Mass
instance GHC.Show.Show PurpleMuon.Physics.Types.Mass
instance GHC.Classes.Eq PurpleMuon.Physics.Types.Mass
instance Data.Binary.Class.Binary PurpleMuon.Physics.Types.Mass
instance Data.Binary.Class.Binary PurpleMuon.Physics.Types.Velocity
instance Data.Binary.Class.Binary PurpleMuon.Physics.Types.ObjType
instance Data.Binary.Class.Binary PurpleMuon.Physics.Types.ObjGrav
instance Data.Binary.Class.Binary PurpleMuon.Physics.Types.PhysicalObject


module PurpleMuon.Physics.Constants
g :: GravitationalConstant
physicalSize :: PhysicalSize

-- | Do physics at 30 Hz
physicsStep :: DeltaTime

-- | The minimum distance two objects are allowed to have This makes the
--   integration numerically much more stable
minimumDistance :: FlType


module PurpleMuon.Physics.Algorithm

-- | Integrate a physical object system. Uses RK4, and the notation from
--   the wikipedia article
--   <a>https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods</a>
integrateTimeStep :: GravitationalConstant -> DeltaTime -> PhysicalObjects -> Forces -> PhysicalObjects


-- | Purple Moun Clients have `8` possible keys they can press. These are
--   
--   <ul>
--   <li>accelerate (up key)</li>
--   <li>turn left (left key)</li>
--   <li>turn right (right key)</li>
--   <li>decelerate (down key)</li>
--   <li>fire 1 (space)</li>
--   <li>fire 2 (s)</li>
--   <li>fire 3 (d)</li>
--   <li>fire 4 (f)</li>
--   </ul>
--   
--   These controls are send from the clients to the server 30 times a
--   second. They packed into a Word8, where the bits signalize pressed (1)
--   or not pressed (0) in the order mentioned above.
module PurpleMuon.Input.Types

-- | A data type that stores information about the current keyboard state
data Controls
Controls :: Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Controls
[accelerate] :: Controls -> Bool
[turn_left] :: Controls -> Bool
[turn_right] :: Controls -> Bool
[decelerate] :: Controls -> Bool
[fire1] :: Controls -> Bool
[fire2] :: Controls -> Bool
[fire3] :: Controls -> Bool
[fire4] :: Controls -> Bool

-- | A data type that stores a keymap. A keymap is a mapping from SDL
--   scancodes to controls defined in the game
data KeyMap
KeyMap :: Scancode -> Scancode -> Scancode -> Scancode -> Scancode -> Scancode -> Scancode -> Scancode -> KeyMap
[km_accel] :: KeyMap -> Scancode
[km_turn_left] :: KeyMap -> Scancode
[km_turn_right] :: KeyMap -> Scancode
[km_decel] :: KeyMap -> Scancode
[km_fire1] :: KeyMap -> Scancode
[km_fire2] :: KeyMap -> Scancode
[km_fire3] :: KeyMap -> Scancode
[km_fire4] :: KeyMap -> Scancode
packControls :: Controls -> Word8
unpackControls :: Word8 -> Controls
instance GHC.Classes.Eq PurpleMuon.Input.Types.KeyMap
instance GHC.Show.Show PurpleMuon.Input.Types.KeyMap
instance GHC.Classes.Eq PurpleMuon.Input.Types.Controls
instance GHC.Show.Show PurpleMuon.Input.Types.Controls


module PurpleMuon.Input.Util

-- | Update the current state of the keyboard
updateKeyboardState :: (MonadIO m, MonadState Controls m) => KeyMap -> m ()

-- | Get the current state of the keyboard
getKeyboardState :: MonadIO m => KeyMap -> m Controls

-- | Standard keymap
standardKeyMap :: KeyMap


module Client.States.MenuState.Events


module Client.States.InGameState.Events


module Client.Network

module Client.Init

-- | Run a computation with SDL, SDL window and SDL renderer, SDL-ttf and
--   SDL-mixer.
withGraphics :: (Window -> Renderer -> IO ()) -> IO (Either SomeException ())

module Client.Image
parseTextureAtlas :: MonadIO m => FilePath -> m (Maybe Element)
filterAtlas :: Text -> Content -> Bool
data Texture
Texture :: TextureAtlas -> Text -> Int -> Int -> Int -> Int -> Texture
[atlas] :: Texture -> TextureAtlas
[name] :: Texture -> Text
[x] :: Texture -> Int
[y] :: Texture -> Int
[width] :: Texture -> Int
[height] :: Texture -> Int
data TextureAtlas

module Client.Assets.Util

-- | A list of all png assets to load on game start. If this list gets too
--   long, maybe it should be split into assets for different stages of the
--   game.
pngAssets :: [FilePath]

-- | Complete list of all sound assets in the game
soundAssets :: [FilePath]

-- | Complete list of all font assets used in the game
fontAssets :: [FilePath]

module Client.Assets.Generic

-- | A unique identifier for assets. The identifier has a phantom type
--   which ensures that id's of different assets can not be mixed.
newtype AssetID a
AssetID :: Text -> AssetID a
[unAssetID] :: AssetID a -> Text
data AssetLoader a b c
AssetLoader :: BasicHashTable Text a -> b -> (c -> b -> FilePath -> IO (Either Text [(AssetID a, a)])) -> (a -> IO ()) -> AssetLoader a b c
[store] :: AssetLoader a b c -> BasicHashTable Text a
[extData] :: AssetLoader a b c -> b
[load] :: AssetLoader a b c -> c -> b -> FilePath -> IO (Either Text [(AssetID a, a)])
[delete] :: AssetLoader a b c -> a -> IO ()

-- | Utiltiy function to manually add an asset
addAsset :: (MonadIO m) => AssetLoader a b c -> a -> AssetID a -> m ()

-- | Utility function to retrieve a single asset
getAsset :: (MonadIO m, MonadError Text m) => AssetLoader a b c -> (AssetID a) -> m a

-- | Utility function for retrieving all assets
getAllIDs :: (MonadIO m) => AssetLoader a b c -> m [AssetID a]

-- | Utility function to load a single asset
loadAsset :: (MonadIO m, MonadError Text m) => AssetLoader a b c -> c -> FilePath -> m [AssetID a]

-- | Utility function to load a single asset for the special case of `c ==
--   ()`
loadAsset_ :: (MonadIO m, MonadError Text m) => AssetLoader a b () -> FilePath -> m [AssetID a]

-- | Utility function to load a bunch of assets into an <a>AssetLoader</a>
--   with a callback function. Also normalizes the paths via the cabal
--   paths.
loadAssets :: forall m a b c. (MonadError Text m, MonadIO m) => AssetLoader a b c -> [(c, FilePath)] -> (Float -> Text -> m ()) -> m ()

-- | Same as <a>loadAssets</a> specialized for `c == ()`
loadAssets_ :: (MonadIO m, MonadError Text m) => AssetLoader a b () -> [FilePath] -> (Float -> Text -> m ()) -> m ()

-- | Utility function to delete allassets in an <a>AssetLoader</a>
deleteAssets :: MonadIO m => AssetLoader a b c -> m ()
instance GHC.Show.Show (Client.Assets.Generic.AssetID a)
instance GHC.Generics.Generic (Client.Assets.Generic.AssetID a)
instance Data.Binary.Class.Binary (Client.Assets.Generic.AssetID b)

module Client.Assets.Sound

-- | Implementation of <tt>AssetLoader</tt> for sounds.
soundLoader :: MonadIO m => m SoundLoaderType

-- | A type of a sound loader
type SoundLoaderType = AssetLoader Chunk () ()

-- | Type of a sound identifier
type SoundID = AssetID Chunk

module Client.Assets.Texture

-- | Implementation of <tt>AssetLoader</tt> for textures
textureLoader :: MonadIO m => Renderer -> m TextureLoaderType

-- | Type of a texture loader
type TextureLoaderType = AssetLoader Texture Renderer ()

-- | Type of a texture identifier
type TextureID = AssetID Texture

module Client.Assets.Sprite

-- | Implementation of <tt>AssetLoader</tt> for sprites
spriteLoader :: MonadIO m => TextureLoaderType -> m SpriteLoaderType
data Sprite
Sprite :: TextureID -> Maybe (Rectangle CInt) -> Point V2 CInt -> Sprite
[texture] :: Sprite -> TextureID
[rect] :: Sprite -> Maybe (Rectangle CInt)
[center] :: Sprite -> Point V2 CInt

-- | Manually add a sprite
manualAdd :: MonadIO m => SpriteLoaderType -> Sprite -> Texture -> AssetID Sprite -> m ()

-- | Type of a sprite loader
type SpriteLoaderType = AssetLoader Sprite TextureLoaderType ()

-- | Type of a sprite loader identifier
type SpriteID = AssetID Sprite


module PurpleMuon.Game.Types

-- | A game object. Has optionally a name and a <tt>PhysicalObject</tt>.
data GameObject
GameObject :: GameObjectData -> Maybe Text -> Maybe PhyObjKey -> Maybe RenderInfo -> GameObject
[_goData] :: GameObject -> GameObjectData
[_mName] :: GameObject -> Maybe Text
[_mPhOb] :: GameObject -> Maybe PhyObjKey
[_mReInfo] :: GameObject -> Maybe RenderInfo
goData :: Lens' GameObject GameObjectData
mName :: Lens' GameObject (Maybe Text)
mPhOb :: Lens' GameObject (Maybe PhyObjKey)
mReInfo :: Lens' GameObject (Maybe RenderInfo)

-- | The type of the game object and the data that goes with it.
data GameObjectData
PlayerShip :: GameObjectData
Comet :: GameObjectData
type GameObjKey = Key GameObject
data Size
Size :: Float -> Float -> Size
[_xSize] :: Size -> Float
[_ySize] :: Size -> Float
xSize :: Lens' Size Float
ySize :: Lens' Size Float
data RenderInfo
RenderInfo :: Position -> FlType -> V2 FlType -> SpriteID -> RenderInfo
[_pos] :: RenderInfo -> Position
[_angle] :: RenderInfo -> FlType
[_size] :: RenderInfo -> V2 FlType
[_sprite] :: RenderInfo -> SpriteID
pos :: Lens' RenderInfo Position
angle :: Lens' RenderInfo FlType
size :: Lens' RenderInfo (V2 FlType)
sprite :: Lens' RenderInfo SpriteID
instance GHC.Generics.Generic PurpleMuon.Game.Types.GameObject
instance GHC.Generics.Generic PurpleMuon.Game.Types.Size
instance GHC.Generics.Generic PurpleMuon.Game.Types.RenderInfo
instance GHC.Generics.Generic PurpleMuon.Game.Types.GameObjectData
instance Data.Binary.Class.Binary PurpleMuon.Game.Types.GameObjectData
instance Data.Binary.Class.Binary PurpleMuon.Game.Types.Size
instance Data.Binary.Class.Binary PurpleMuon.Game.Types.RenderInfo
instance Data.Binary.Class.Binary PurpleMuon.Game.Types.GameObject


module PurpleMuon.Network.Types

-- | A binary message that is send over the network
newtype RawMessage
RawMessage :: ByteString -> RawMessage
[unRawMessage] :: RawMessage -> ByteString

-- | A binary message without a uuid header
newtype NakedMessage
NakedMessage :: ByteString -> NakedMessage
[unNakedMessage] :: NakedMessage -> ByteString

-- | A uuid is a header that the server and client prepends to every
--   message. A message that does not have such a header is discarded
--   immediately
type ProtocolUUID = ByteString

-- | The payload of a Message
newtype Payload
Payload :: ByteString -> Payload
[unPayload] :: Payload -> ByteString

-- | A counter to count both the remote and local messages
newtype MessageCount
MessageCount :: Word32 -> MessageCount
[unMessageCounter] :: MessageCount -> Word32

-- | A field indicating which of the last 32 messages have arrived.
newtype AckField
AckField :: Word32 -> AckField
[unAckField] :: AckField -> Word32

-- | A difference between to Message counts
newtype Offset
Offset :: Int -> Offset
[unOffset] :: Offset -> Int

-- | A Configuration of a connection
data NetworkConfig
ConnectionConfig :: Int -> NetworkConfig
[maxClients] :: NetworkConfig -> Int
data NetworkState
NetworkState :: Socket -> NetworkState
[socket] :: NetworkState -> Socket
data ConnectionState
ConnectionState :: SockAddr -> MessageCount -> ConnectionState
[addr] :: ConnectionState -> SockAddr
[latestCounter] :: ConnectionState -> MessageCount

-- | Messages the Server sends to the Clients
data ServerToClientMsg

-- | A simple ping package to determine network latency
Ping :: ServerToClientMsg

-- | Create a new game object
CreateGameObject :: (GameObjKey, GameObject, Maybe PhysicalObject) -> ServerToClientMsg

-- | The physical objects in the system TODO: Pack this better. Also send
--   the generation of the data
Update :: PhysicalObjects -> ServerToClientMsg

-- | Messages the Clients send to the Server
data ClientToServerMsg

-- | Request a connection to the server. The sever will answer with ping
--   commands to establish the network latency if the request is granted
RequestConnection :: PlayerName -> ClientToServerMsg

-- | Answer to a ping command. The <a>MessageCount</a> indicates which
Pong :: MessageCount -> ClientToServerMsg

-- | Regular updates the client sends to the server
ClientUpdate :: UpdateMsg -> ClientToServerMsg

-- | A player name
newtype PlayerName
PlayerName :: Text -> PlayerName
[unPlayerName] :: PlayerName -> Text
data UpdateMsg
UpdateMsg :: Word32 -> Word32 -> Word8 -> UpdateMsg
[lastAck] :: UpdateMsg -> Word32
[ackField] :: UpdateMsg -> Word32
[controls] :: UpdateMsg -> Word8
instance GHC.Generics.Generic PurpleMuon.Network.Types.ClientToServerMsg
instance GHC.Generics.Generic PurpleMuon.Network.Types.UpdateMsg
instance GHC.Generics.Generic PurpleMuon.Network.Types.PlayerName
instance GHC.Generics.Generic PurpleMuon.Network.Types.ServerToClientMsg
instance GHC.Generics.Generic PurpleMuon.Network.Types.MessageCount
instance Data.Binary.Class.Binary PurpleMuon.Network.Types.MessageCount
instance Data.Binary.Class.Binary PurpleMuon.Network.Types.PlayerName
instance Data.Binary.Class.Binary PurpleMuon.Network.Types.ServerToClientMsg
instance Data.Binary.Class.Binary PurpleMuon.Network.Types.ClientToServerMsg
instance Data.Binary.Class.Binary PurpleMuon.Network.Types.UpdateMsg


module PurpleMuon.Network.Message

-- | Prepend a message with an crc32 checksum.
prepend :: ProtocolUUID -> NakedMessage -> RawMessage

-- | strip an crc32 off of a message. Returns Just (stripped message) if
--   the message contains the correct uuid and Nothing otherwise
strip :: ProtocolUUID -> RawMessage -> Maybe NakedMessage

-- | Calculate the next message count
nextMC :: MessageCount -> MessageCount

-- | Calculate the offset of two message types. Guarantees that
--   
--   <pre>
--   moveMC a (diffMC a b) = b
--   </pre>
--   
--   for all MessageCounts a and b.
diffMC :: MessageCount -> MessageCount -> Offset

-- | Move a MessageCount by a given offset
moveMC :: MessageCount -> Offset -> MessageCount


module PurpleMuon.Network.Util

-- | Open a UDP Socket on a specific port
serverSocket :: MonadIO m => Text -> m (Either SomeException Socket)

-- | Connect an UDP socket to a specific port
clientSocket :: MonadIO m => Text -> Text -> m (Either SomeException Socket)

-- | Endless receiving queue forkIO this and give it a STM object to write
--   stuff to. It will block on UDP recv and as soon as something arrives
--   write it to the output
endlessRecv :: MonadIO m => ProtocolUUID -> Int -> Socket -> TBQueue ServerToClientMsg -> m ()

module Server.Types

-- | The state of a server waiting for connections
data WaitingState
WaitingState :: [ClientConnection] -> WaitingState
[_clientsConnected] :: WaitingState -> [ClientConnection]

-- | The state of a server in game
data GameState
GameState :: IntMap GameObject -> PhysicalObjects -> UTCTime -> [ClientConnection] -> Word32 -> GameState
[_gObjs] :: GameState -> IntMap GameObject
[_pObjs] :: GameState -> PhysicalObjects
[_frameBegin] :: GameState -> UTCTime
[_clients] :: GameState -> [ClientConnection]

-- | Count of integration steps
[_intStep] :: GameState -> Word32
gObjs :: Lens' GameState (IntMap GameObject)
pObjs :: Lens' GameState PhysicalObjects
frameBegin :: Lens' GameState UTCTime
clients :: Lens' GameState [ClientConnection]
logger :: Lens' Resources LoggerSet
intStep :: Lens' GameState Word32
type WaitingServer a = ReaderT Resources (StateT WaitingState IO) a
clientsConnected :: Iso' WaitingState [ClientConnection]
type Server a = ReaderT Resources (StateT GameState IO) a

-- | Read only resources that the server has access to
data Resources
Resources :: TBQueue NakedMessage -> Socket -> LoggerSet -> ProtocolUUID -> Resources
[_tbqueue] :: Resources -> TBQueue NakedMessage
[_socket] :: Resources -> Socket
[_logger] :: Resources -> LoggerSet
[_uuid] :: Resources -> ProtocolUUID
tbqueue :: Lens' Resources (TBQueue NakedMessage)
socket :: Lens' Resources Socket
uuid :: Lens' Resources ProtocolUUID

-- | A client connection saves all the data the server knows about a client
data ClientConnection
ClientConnection :: SockAddr -> Text -> ClientConnectionType -> ClientConnection
[_addr] :: ClientConnection -> SockAddr
[_name] :: ClientConnection -> Text
[_connType] :: ClientConnection -> ClientConnectionType
addr :: Lens' ClientConnection SockAddr
name :: Lens' ClientConnection Text
connType :: Lens' ClientConnection ClientConnectionType

-- | The type of client connection
data ClientConnectionType
ClientConnectionPlayer :: GameObjKey -> Controls -> ClientConnectionType
[playerObj] :: ClientConnectionType -> GameObjKey
[inputControls] :: ClientConnectionType -> Controls
ClientConnectionViewer :: ClientConnectionType

module Server.Frames
frameBegin :: Server ()
manageFps :: Server ()

module Server.Network

-- | Send a package to a client. Don't request an acknowledgment of
--   arrival.
sendPackage :: (MonadReader Resources m, MonadIO m) => ServerToClientMsg -> ClientConnection -> m ()

-- | Send a package to all clients. Don't request an acknowledgment of
--   arrival.
sendPackageToAll :: (MonadState [ClientConnection] m, MonadReader Resources m, MonadIO m) => ServerToClientMsg -> m ()

-- | Send a complete game state to a client
sendGameState :: (MonadReader Resources m, MonadIO m) => PhysicalObjects -> IntMap GameObject -> ClientConnection -> m ()

module Server.MainLoop
loop :: Server ()

module Client.Video.Sprite

-- | Render a sprite
--   
--   TODO: The renderer as an argument is unnecessary if we take it out of
--   the Textureloader
renderSprite :: (MonadIO m, MonadError Text m) => Renderer -> SpriteLoaderType -> SpriteID -> Maybe (Rectangle CInt) -> CDouble -> V2 Bool -> m ()

-- | Draw sprite without flipping
noFlip :: V2 Bool
renderGameObject :: (MonadIO m, MonadError Text m) => Renderer -> SpriteLoaderType -> Resolution -> GameObject -> m ()

-- | Update the sprite position with the position of the physical Object
updateRenderInfo :: PhysicalObjects -> GameObject -> GameObject
relToAbs :: Resolution -> Rectangle FlType -> Rectangle CInt

module Client.Video.Menu
data MenuItem
MenuItem :: Rectangle FlType -> MenuType -> MenuItem
[pos] :: MenuItem -> Rectangle FlType
[mType] :: MenuItem -> MenuType
data MenuType
Label :: SpriteID -> MenuType
[labelSprite] :: MenuType -> SpriteID
Button :: SpriteID -> SpriteID -> MenuType
[button] :: MenuType -> SpriteID
[buttonLabel] :: MenuType -> SpriteID
InputField :: MenuType

-- | Make a new label
mkLabel :: (MonadIO m, MonadError Text m) => SpriteLoaderType -> Renderer -> Color -> Position -> Size -> Text -> Font -> m MenuItem

-- | Render a menu item
renderMenuItem :: (MonadIO m, MonadError Text m) => SpriteLoaderType -> Renderer -> MenuItem -> m ()
instance GHC.Show.Show Client.Video.Menu.MenuItem
instance GHC.Show.Show Client.Video.Menu.MenuType

module Server.Config
initialObjs :: IntMap GameObject
initialPhyObjs :: PhysicalObjects


module Server.WaitingLoop
waitingLoop :: WaitingServer ()

module Server.Main
main :: IO ()

-- | Initialize the loop state
initLoop :: MonadIO m => CommandLineOptions -> m ()


module Client.Assets.Font

-- | A type of a font loader
type FontLoaderType = AssetLoader Font () FontSize

-- | Type of a font identifier
type FontID = AssetID Font

-- | Map a fontname + size to a font id
toFontID :: FilePath -> FontSize -> FontID

-- | The size of a font
newtype FontSize
FontSize :: Int -> FontSize
[unFontSize] :: FontSize -> Int

-- | Implementation of <tt>AssetLoader</tt> for sounds.
fontLoader :: MonadIO m => m FontLoaderType


module Client.States.InGameState.Types
data State
State :: PhysicalObjects -> DeltaTime -> IntMap GameObject -> Controls -> NetworkState -> KeyMap -> SpriteLoaderType -> FontLoaderType -> State
[_physicalObjects] :: State -> PhysicalObjects

-- | Accumulated time for fixed physics step
[_accumTime] :: State -> DeltaTime
[_gameObjects] :: State -> IntMap GameObject
[_controls] :: State -> Controls
[_netState] :: State -> NetworkState
[_keymap] :: State -> KeyMap
[_gameSprites] :: State -> SpriteLoaderType
[_gameFonts] :: State -> FontLoaderType
physicalObjects :: Lens' State PhysicalObjects
accumTime :: Lens' State DeltaTime
gameObjects :: Lens' State (IntMap GameObject)
controls :: Lens' State Controls
netState :: Lens' State NetworkState
keymap :: Lens' State KeyMap
gameFonts :: Lens' State FontLoaderType
gameSprites :: Lens' State SpriteLoaderType

-- | The network state of a client. This data type contains every
--   information that is available for a connection to a game server.
data NetworkState
NetworkState :: UTCTime -> MessageCount -> AckField -> Socket -> TBQueue ServerToClientMsg -> NetworkState
[_lastPacket] :: NetworkState -> UTCTime
[_lastID] :: NetworkState -> MessageCount
[_ackField] :: NetworkState -> AckField
[_socket] :: NetworkState -> Socket
[_tbqueue] :: NetworkState -> TBQueue ServerToClientMsg
lastPacket :: Lens' NetworkState UTCTime
lastID :: Lens' NetworkState MessageCount
ackField :: Lens' NetworkState AckField
socket :: Lens' NetworkState Socket
tbqueue :: Lens' NetworkState (TBQueue ServerToClientMsg)


module Client.States.MenuState.Types
data State
State :: SpriteLoaderType -> [MenuItem] -> FontLoaderType -> State
[_menuSprites] :: State -> SpriteLoaderType
[_menuItems] :: State -> [MenuItem]
[_menuFonts] :: State -> FontLoaderType
menuSprites :: Lens' State SpriteLoaderType
menuItems :: Lens' State [MenuItem]
menuFonts :: Lens' State FontLoaderType


module Client.States.Types
data State
InGameState :: State -> State
[_inGameState] :: State -> State
MenuState :: State -> State
[_menuState] :: State -> State
inGameState :: Traversal' State State
menuState :: Traversal' State State


module Client.States.MenuState.Init

-- | initialize a new menu
initMenu :: MonadIO m => Renderer -> m State

module Client.Types

-- | The <a>AppState</a> holds all information of the entire application.
data AppState
AppState :: Bool -> State -> FrameState -> AppState
[_running] :: AppState -> Bool
[_game] :: AppState -> State
[_frameState] :: AppState -> FrameState
running :: Lens' AppState Bool
game :: Lens' AppState State
frameState :: Lens' AppState FrameState
type Game a = ReaderT Resources (StateT AppState IO) a

-- | The frame state contains information on the app's fps.
data FrameState
FrameState :: FpsCounter -> UTCTime -> DeltaTime -> FrameState
[_fpsCounter] :: FrameState -> FpsCounter
[_frameBegin] :: FrameState -> UTCTime
[_dt] :: FrameState -> DeltaTime
fpsCounter :: Lens' FrameState FpsCounter
frameBegin :: Lens' FrameState UTCTime
dt :: Lens' FrameState DeltaTime

-- | Resources are things that do not change during a complete app cycle.
data Resources
Resources :: Window -> Renderer -> Resources
[_window] :: Resources -> Window
[_renderer] :: Resources -> Renderer
window :: Lens' Resources Window
renderer :: Lens' Resources Renderer
data FpsCounter
FpsCounter :: Int -> [FlType] -> FpsCounter
[maxFrames] :: FpsCounter -> Int
[fpsL] :: FpsCounter -> [FlType]
instance GHC.Show.Show Client.Types.FpsCounter

module Client.Event
handleEvent :: Event -> Game ()


module Client.Frames

-- | Manage the beginning of a frame, i.e. store the current time
frameBegin :: (MonadIO m, MonadState UTCTime m) => m ()

-- | Manage the end of a frame. Sleeps, times and updates the frame counter
manageFps :: (MonadIO m, MonadState FrameState m) => m ()
formatFps :: FpsCounter -> Text


module Client.States.InGameState.Loop

-- | The loop while being in game Note that loop should _not_ pass any
--   errors further along, unless they are fatal. There is no recovery
--   beyond this point, hence no MonadError.
loop :: (MonadIO m, MonadState State m, MonadReader Resources m) => m ()


module Client.States.MenuState.Loop

-- | The loop while being in the menu. Note that loop should _not_ pass any
--   errors further along, unless they are fatal. There is no recovery
--   beyond this point, hence no MonadError.
loop :: (MonadIO m, MonadState State m, MonadReader Resources m) => m ()

module Client.Loop
loop :: Game ()

module Client.Main
uuid :: ProtocolUUID
initialeState :: MonadIO m => Renderer -> m AppState
game :: Window -> Renderer -> IO ()
main :: IO ()
