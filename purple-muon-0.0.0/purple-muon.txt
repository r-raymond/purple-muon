-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A multiplayer space game
--   
--   Please see README.md
@package purple-muon
@version 0.0.0

module Version
gitTag :: Text
platform :: Text
compiler :: Text


-- | This module defines common lifting operations into MonadError.
module PurpleMuon.Util.MonadError

-- | Lift a Maybe into an error monad
liftMaybe :: (MonadError e m) => e -> Maybe a -> m a

-- | Lift Either into error monad This version additionally allows to
--   specify a transformation for the <a>Left</a> value.
liftEitherWith :: (MonadError e m) => (f -> e) -> Either f a -> m a

-- | Lift Either into error monad Throws error on <a>Left</a> Value.
liftEither :: (MonadError e m) => Either e a -> m a


module PurpleMuon.Physics.Types

-- | A physical object identifier
newtype PhyObjUUID
PhyObjUUID :: Word16 -> PhyObjUUID
[unPhyObjUUID] :: PhyObjUUID -> Word16

-- | The floating point type used throughout the physics module
type FlType = Float

-- | The position of an object
newtype Position
Position :: V2 FlType -> Position
[unPosition] :: Position -> V2 FlType

-- | The mass of an object
newtype Mass
Mass :: FlType -> Mass
[unMass] :: Mass -> FlType

-- | The velocity of an object
newtype Velocity
Velocity :: V2 FlType -> Velocity
[unVelocity] :: Velocity -> V2 FlType

-- | The acceleration of an object
newtype Acceleration
Acceleration :: V2 FlType -> Acceleration
[unAcceleration] :: Acceleration -> V2 FlType

-- | A time delta Meassured in seconds
newtype DeltaTime
DeltaTime :: FlType -> DeltaTime
[unDeltaTime] :: DeltaTime -> FlType

-- | A Force
newtype Force
Force :: V2 FlType -> Force
[unForce] :: Force -> V2 FlType

-- | The gravitaional constant
newtype GravitationalConstant
GravitationalConstant :: FlType -> GravitationalConstant
[unGravitationalConstant] :: GravitationalConstant -> FlType

-- | A physical object
data PhysicalObject
PhysicalObject :: Mass -> Position -> Velocity -> ObjType -> ObjGrav -> PhysicalObject

-- | The mass of the object
[_mass] :: PhysicalObject -> Mass

-- | The position of the object
[_pos] :: PhysicalObject -> Position

-- | The velocity of the object
[_vel] :: PhysicalObject -> Velocity

-- | Is this object moving?
[_static] :: PhysicalObject -> ObjType

-- | Is this object gravitating?
[_gravitating] :: PhysicalObject -> ObjGrav
mass :: Lens' PhysicalObject Mass
pos :: Lens' PhysicalObject Position
vel :: Lens' PhysicalObject Velocity
static :: Lens' PhysicalObject ObjType
gravitating :: Lens' PhysicalObject ObjGrav

-- | The physical size of the playing board
newtype PhysicalSize
PhysicalSize :: V2 FlType -> PhysicalSize
[unPhysicalSize] :: PhysicalSize -> V2 FlType

-- | The derivaties of a physical object numerical integrater
newtype Derivative
Derivative :: (Velocity, Force) -> Derivative
[unDerviative] :: Derivative -> (Velocity, Force)

-- | A collection of derivaties, indexed by the <tt>uuid</tt> of the
--   objects
type Derivatives = IntMap Derivative

-- | A collection of objects, indexed by the <tt>uuid</tt> of the objects
type PhysicalObjects = IntMap PhysicalObject

-- | A collection of forces, indexed by the <tt>uuid</tt> of the objects
type Forces = IntMap Force

-- | The type of a gravitating body
data ObjGrav

-- | the object exerts gravitational forces
Gravitating :: ObjGrav

-- | the object only recerives grav. forces
NonGravitating :: ObjGrav

-- | The type of a physical object
data ObjType

-- | the objects position is fixed
Static :: ObjType

-- | the objects position is not fixed
NonStatic :: ObjType
instance GHC.Generics.Generic PurpleMuon.Physics.Types.Derivative
instance GHC.Show.Show PurpleMuon.Physics.Types.Derivative
instance GHC.Classes.Eq PurpleMuon.Physics.Types.Derivative
instance GHC.Generics.Generic PurpleMuon.Physics.Types.PhysicalSize
instance GHC.Show.Show PurpleMuon.Physics.Types.PhysicalSize
instance GHC.Classes.Eq PurpleMuon.Physics.Types.PhysicalSize
instance Data.AdditiveGroup.AdditiveGroup PurpleMuon.Physics.Types.Force
instance Data.VectorSpace.VectorSpace PurpleMuon.Physics.Types.Force
instance Data.AdditiveGroup.AdditiveGroup PurpleMuon.Physics.Types.Velocity
instance Data.VectorSpace.VectorSpace PurpleMuon.Physics.Types.Velocity
instance Data.AdditiveGroup.AdditiveGroup PurpleMuon.Physics.Types.Acceleration
instance Data.VectorSpace.VectorSpace PurpleMuon.Physics.Types.Acceleration
instance Data.AdditiveGroup.AdditiveGroup PurpleMuon.Physics.Types.Derivative
instance Data.VectorSpace.VectorSpace PurpleMuon.Physics.Types.Derivative
instance Data.AdditiveGroup.AdditiveGroup PurpleMuon.Physics.Types.DeltaTime
instance GHC.Generics.Generic PurpleMuon.Physics.Types.PhysicalObject
instance GHC.Show.Show PurpleMuon.Physics.Types.PhysicalObject
instance GHC.Generics.Generic PurpleMuon.Physics.Types.ObjGrav
instance GHC.Show.Show PurpleMuon.Physics.Types.ObjGrav
instance GHC.Classes.Eq PurpleMuon.Physics.Types.ObjGrav
instance GHC.Generics.Generic PurpleMuon.Physics.Types.ObjType
instance GHC.Show.Show PurpleMuon.Physics.Types.ObjType
instance GHC.Classes.Eq PurpleMuon.Physics.Types.ObjType
instance GHC.Generics.Generic PurpleMuon.Physics.Types.GravitationalConstant
instance GHC.Show.Show PurpleMuon.Physics.Types.GravitationalConstant
instance GHC.Classes.Eq PurpleMuon.Physics.Types.GravitationalConstant
instance GHC.Generics.Generic PurpleMuon.Physics.Types.Force
instance GHC.Show.Show PurpleMuon.Physics.Types.Force
instance GHC.Classes.Eq PurpleMuon.Physics.Types.Force
instance GHC.Generics.Generic PurpleMuon.Physics.Types.DeltaTime
instance GHC.Classes.Ord PurpleMuon.Physics.Types.DeltaTime
instance GHC.Show.Show PurpleMuon.Physics.Types.DeltaTime
instance GHC.Classes.Eq PurpleMuon.Physics.Types.DeltaTime
instance GHC.Generics.Generic PurpleMuon.Physics.Types.Acceleration
instance GHC.Show.Show PurpleMuon.Physics.Types.Acceleration
instance GHC.Classes.Eq PurpleMuon.Physics.Types.Acceleration
instance GHC.Generics.Generic PurpleMuon.Physics.Types.Velocity
instance GHC.Show.Show PurpleMuon.Physics.Types.Velocity
instance GHC.Classes.Eq PurpleMuon.Physics.Types.Velocity
instance GHC.Generics.Generic PurpleMuon.Physics.Types.Mass
instance GHC.Show.Show PurpleMuon.Physics.Types.Mass
instance GHC.Classes.Eq PurpleMuon.Physics.Types.Mass
instance GHC.Generics.Generic PurpleMuon.Physics.Types.Position
instance GHC.Show.Show PurpleMuon.Physics.Types.Position
instance GHC.Classes.Eq PurpleMuon.Physics.Types.Position
instance GHC.Real.Integral PurpleMuon.Physics.Types.PhyObjUUID
instance GHC.Enum.Enum PurpleMuon.Physics.Types.PhyObjUUID
instance GHC.Real.Real PurpleMuon.Physics.Types.PhyObjUUID
instance GHC.Num.Num PurpleMuon.Physics.Types.PhyObjUUID
instance GHC.Classes.Ord PurpleMuon.Physics.Types.PhyObjUUID
instance GHC.Classes.Eq PurpleMuon.Physics.Types.PhyObjUUID
instance Data.Binary.Class.Binary PurpleMuon.Physics.Types.Mass
instance Data.Binary.Class.Binary PurpleMuon.Physics.Types.Position
instance Data.Binary.Class.Binary PurpleMuon.Physics.Types.Velocity
instance Data.Binary.Class.Binary PurpleMuon.Physics.Types.ObjType
instance Data.Binary.Class.Binary PurpleMuon.Physics.Types.ObjGrav
instance Data.Binary.Class.Binary PurpleMuon.Physics.Types.PhysicalObject


module PurpleMuon.Physics.Constants
g :: GravitationalConstant
physicalSize :: PhysicalSize

-- | Do physics at 30 Hz
physicsStep :: DeltaTime

-- | The minimum distance two objects are allowed to have This makes the
--   integration numerically much more stable
minimumDistance :: FlType


module PurpleMuon.Physics.Algorithm

-- | Integrate a physical object system. Uses RK4, and the notation from
--   the wikipedia article
--   <a>https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods</a>
integrateTimeStep :: GravitationalConstant -> DeltaTime -> PhysicalObjects -> Forces -> PhysicalObjects


module PurpleMuon.Network.Types

-- | A binary message that is send over the network
newtype RawMessage
RawMessage :: ByteString -> RawMessage
[unRawMessage] :: RawMessage -> ByteString

-- | A binary message without a uuid header
newtype NakedMessage
NakedMessage :: ByteString -> NakedMessage
[unNakedMessage] :: NakedMessage -> ByteString

-- | A uuid is a header that the server and client prepends to every
--   message. A message that does not have such a header is discarded
--   immediately
newtype UUID
UUID :: ByteString -> UUID
[unUUID] :: UUID -> ByteString

-- | The payload of a Message
newtype Payload
Payload :: ByteString -> Payload
[unPayload] :: Payload -> ByteString

-- | A counter to count both the remote and local messages
newtype MessageCount
MessageCount :: Word32 -> MessageCount
[unMessageCounter] :: MessageCount -> Word32

-- | A field indicating which of the last 32 messages have arrived.
newtype AckField
AckField :: Word32 -> AckField
[unAckField] :: AckField -> Word32

-- | A difference between to Message counts
newtype Offset
Offset :: Int -> Offset
[unOffset] :: Offset -> Int

-- | A Configuration of a connection
data NetworkConfig
ConnectionConfig :: Int -> NetworkConfig
[maxClients] :: NetworkConfig -> Int
data NetworkState
NetworkState :: Socket -> NetworkState
[socket] :: NetworkState -> Socket
data ConnectionState
ConnectionState :: SockAddr -> MessageCount -> ConnectionState
[addr] :: ConnectionState -> SockAddr
[latestCounter] :: ConnectionState -> MessageCount

-- | Messages the Server sends to the Clients
data ServerToClientMsg

-- | A simple ping package to determine network latency
Ping :: ServerToClientMsg

-- | An update the server sends to the clients
Update :: PhysicalObjects -> ServerToClientMsg

-- | Messages the Clients send to the Server
data ClientToServerMsg

-- | Request a connection to the server. The sever will answer with ping
--   commands to establish the network latency if the request is granted
RequestConnection :: PlayerName -> ClientToServerMsg

-- | Answer to a ping command. The <a>MessageCount</a> indicates which
Pong :: MessageCount -> ClientToServerMsg

-- | A player name
newtype PlayerName
PlayerName :: Text -> PlayerName
[unPlayerName] :: PlayerName -> Text
instance GHC.Generics.Generic PurpleMuon.Network.Types.ClientToServerMsg
instance GHC.Generics.Generic PurpleMuon.Network.Types.PlayerName
instance GHC.Generics.Generic PurpleMuon.Network.Types.ServerToClientMsg
instance GHC.Generics.Generic PurpleMuon.Network.Types.MessageCount
instance Data.Binary.Class.Binary PurpleMuon.Network.Types.MessageCount
instance Data.Binary.Class.Binary PurpleMuon.Network.Types.PlayerName
instance Data.Binary.Class.Binary PurpleMuon.Network.Types.ServerToClientMsg
instance Data.Binary.Class.Binary PurpleMuon.Network.Types.ClientToServerMsg


module PurpleMuon.Network.Message

-- | Prepend a message with an uuid.
prepend :: UUID -> NakedMessage -> RawMessage

-- | strip an uuid off of a message. Returns Just (stripped message) if the
--   message contains the correct uuid and Nothing otherwise
strip :: UUID -> RawMessage -> Maybe NakedMessage

-- | Calculate the next message count
nextMC :: MessageCount -> MessageCount

-- | Calculate the offset of two message types. Guarantees that
--   
--   <pre>
--   moveMC a (diffMC a b) = b
--   </pre>
--   
--   for all MessageCounts a and b.
diffMC :: MessageCount -> MessageCount -> Offset

-- | Move a MessageCount by a given offset
moveMC :: MessageCount -> Offset -> MessageCount


module PurpleMuon.Network.Util

-- | Open a UDP Socket on a specific port
serverSocket :: MonadIO m => Text -> m (Either SomeException Socket)

-- | Connect an UDP socket to a specific port
clientSocket :: MonadIO m => Text -> Text -> m (Either SomeException Socket)

-- | Endless receiving queue forkIO this and give it a STM object to write
--   stuff to. It will block on UDP recv and as soon as something arrives
--   write it to the output
endlessRecv :: MonadIO m => UUID -> Int -> Socket -> TBQueue NakedMessage -> m ()

module Server.Main
main :: IO ()

module Client.Video.Types
newtype TextureAtlas
TextureAtlas :: Texture -> TextureAtlas
[unTextureAtlas] :: TextureAtlas -> Texture
data Texture
Texture :: AtlasUUID -> Text -> Rectangle CInt -> Texture
[atlas] :: Texture -> AtlasUUID
[name] :: Texture -> Text
[rect] :: Texture -> Rectangle CInt
data TextureLoader
TextureLoader :: IntMap TextureAtlas -> IntMap Texture -> Renderer -> AtlasUUID -> TextureLoader
[atlases] :: TextureLoader -> IntMap TextureAtlas
[textures] :: TextureLoader -> IntMap Texture
[renderer] :: TextureLoader -> Renderer
[nextKey] :: TextureLoader -> AtlasUUID
newtype TexUUID
TexUUID :: Int -> TexUUID
[unTexUUID] :: TexUUID -> Int
type Position = (Word16, Word16)
type AtlasUUID = Int
data RenderTexture
RenderTexture :: TexUUID -> Position -> RenderTexture
[uuid] :: RenderTexture -> TexUUID
[pos] :: RenderTexture -> Position


-- | This module uses SDL2 and JuicyPixels to work with textures.
--   JuicyPixels is used to load arbitrary image formats. These are then
--   converted to RGBA8 images which SDL2 uses to upload to the video card.
--   
--   All image files need to have an accompanying texture atlas file. This
--   file needs to satisfy the following criteria:
--   
--   <ul>
--   <li>it needs to be a valid xml file</li>
--   <li>it has to consist of a single outer xml element which has the
--   property <tt>imagePath</tt>, with value the path of the actual image
--   file (specified from the root of the git repository)</li>
--   <li>the content of the single outer xml element has to be more xml
--   elements, which have the following properties:<ul><li><tt>name</tt>:
--   The name that is used to load this file</li><li><tt>x</tt>: The
--   <tt>x</tt> offset in the image specified by
--   <tt>imagePath</tt></li><li><tt>y</tt>: The <tt>y</tt> offset in the
--   image specified by <tt>imagePath</tt></li><li><tt>width</tt>: The
--   width of the texture</li><li><tt>height</tt>: The height of the
--   texture</li></ul></li>
--   </ul>
--   
--   The names of the xml elements are arbitrary. Anything besides the
--   above mentioned will be ignored and can safely be used to encode
--   additional information.
module Client.Video.Texture

-- | Create a new texture loader.
newTextureLoader :: Renderer -> TextureLoader

-- | Render a texture specified by a <a>TexUUID</a>.
renderTexture :: (MonadIO m) => TextureLoader -> TexUUID -> Maybe (Rectangle CInt) -> m ()

-- | Add an texture atlas to a texture loader
addTextureAtlas :: (MonadError Text m, MonadIO m) => TextureLoader -> FilePath -> m TextureLoader

-- | Find the <a>TexUUID</a> of a texture.
getTexture :: TextureLoader -> Text -> Maybe TexUUID

module Client.Types
data AppState
AppState :: Bool -> GameState -> FpsCounter -> UTCTime -> TextureLoader -> AppState
[_running] :: AppState -> Bool
[_game] :: AppState -> GameState
[_fps] :: AppState -> FpsCounter
[_frameBegin] :: AppState -> UTCTime
[_textures] :: AppState -> TextureLoader
running :: Lens' AppState Bool
game :: Lens' AppState GameState
fps :: Lens' AppState FpsCounter
frameBegin :: Lens' AppState UTCTime
textures :: Lens' AppState TextureLoader
type Game a = ReaderT Resources (StateT AppState IO) a
data GameState
GameState :: PhysicalObjects -> DeltaTime -> DeltaTime -> GameState
[_physicalObjects] :: GameState -> PhysicalObjects
[_dt] :: GameState -> DeltaTime

-- | Accumulated time for fixed physics step
[_accumTime] :: GameState -> DeltaTime
physicalObjects :: Lens' GameState PhysicalObjects
dt :: Lens' GameState DeltaTime
accumTime :: Lens' GameState DeltaTime
data Resources
Resources :: Window -> Renderer -> TBQueue NakedMessage -> Resources
[_window] :: Resources -> Window
[_renderer] :: Resources -> Renderer
[_tbqueue] :: Resources -> TBQueue NakedMessage
window :: Lens' Resources Window
renderer :: Lens' Resources Renderer
tbqueue :: Lens' Resources (TBQueue NakedMessage)
data FpsCounter
FpsCounter :: Int -> [FlType] -> FpsCounter
[maxFrames] :: FpsCounter -> Int
[fpsL] :: FpsCounter -> [FlType]
data TextureUUIDs
TextureUUIDs :: TexUUID -> TexUUID -> TextureUUIDs
[background] :: TextureUUIDs -> TexUUID
[stones] :: TextureUUIDs -> TexUUID
instance GHC.Show.Show Client.Types.FpsCounter

module Client.Init

-- | Run a computation with SDL, SDL window and SDL renderer, SDL-ttf and
--   SDL-mixer.
withGraphics :: (Window -> Renderer -> IO ()) -> IO (Either SomeException ())

module Client.Image
parseTextureAtlas :: MonadIO m => FilePath -> m (Maybe Element)
filterAtlas :: Text -> Content -> Bool
data Texture
Texture :: TextureAtlas -> Text -> Int -> Int -> Int -> Int -> Texture
[atlas] :: Texture -> TextureAtlas
[name] :: Texture -> Text
[x] :: Texture -> Int
[y] :: Texture -> Int
[width] :: Texture -> Int
[height] :: Texture -> Int
data TextureAtlas

module Client.Frames
frameBegin :: Game ()
manageFps :: Game ()
formatFps :: Game Text

module Client.Event
handleEvent :: Event -> Game ()

module Client.MainLoop
loop :: TextureUUIDs -> Game ()
initLoop :: Game ()

module Client.Main
uuid :: UUID
initialeState :: Renderer -> AppState
game :: TBQueue NakedMessage -> Window -> Renderer -> IO ()
main :: IO ()
